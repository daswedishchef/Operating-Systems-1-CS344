#!/bin/bash
valid2=0
var=0
var2=0

#Argument verification block

case $# in
    1)
        echo "Please include matrix" >&2
        exit 3
        ;;
    2)
        if [[ -r $2 && -s $2 ]]
        then
            var="/nfs/stak/users/carlsosp/os1/prog1/$2"
        else
            echo "Enter valid matrix" >&2
            exit 1
        fi
        ;;
    3)
        if [[ -r $2 && -s $2 ]]
        then
            if [[ -r $3 && -s $3 ]]
            then
                valid2=1
                var="/nfs/stak/users/carlsosp/os1/prog1/$2"
                var2="/nfs/stak/users/carlsosp/os1/prog1/$3"
            else
                echo "Error reading second matrix" >&2
                exit 1
            fi
        else
            echo "Error reading first matrix" >&2
            exit 1
        fi
        ;;
esac

#execution block

case $1 in
    dims)
        if [ $valid2 -ne 0 ]
        then
            echo "only one matrix allowed" >&2
            exit 1
        fi
        row=$(wc -l < $var)
        printf "$row "
        read -a arr < "$var"
        printf "${#arr[@]}\n"
        exit 0
        ;;
    transpose)
        if [ $valid2 -ne 0 ]
        then
            echo "Only one matrix allowed" >&2
            exit 1
        fi
        rows=0
        i=0
        declare -a output=()
        while read -a arr2 ;
        do
            for ((j=0; j<${#arr2[@]}; j++))
            do
                output[$i]=${arr2[$j]}
                ((i+=1))
            done
            ((rows+=1))
        done < "$var"
        read -a top < "$var"
        cols=${#top[@]}
        len=${#output[@]}
        j=0
        for ((i=0; i<$cols; i++))
        do
            for ((j=i; j<len-cols; j+=cols))
            do
                printf "%s"${output[j]}
                printf "	"
            done
            printf "%s"${output[j]}
            printf "\n"
        done
        exit 0
        ;;
    mean)
        if [ $valid2 -ne 0 ]
        then
            echo "Only one matrix allowed" >&2
            exit 1
        fi
        declare -a sum=()
        row=0
        i=0
        while read -a meanln ;
        do
            for ((i=0; i<${#meanln[@]}; i++))
            do
                ((sum[i] += meanln[i]))
            done
            ((row+=1))
        done < "$var"
        len=${#sum[@]}
        for ((i=0; i<len-1; i++))
        do
            sum[$i]=$((sum[i] / row))
            printf "%s"${sum[$i]}
            printf "	"
        done
        sum[$i]=$((sum[i] / row))
        printf "%s"${sum[$i]}
        printf "\n"
        exit 0
        ;;
    add)
        if [ $valid2 -ne 1 ]
        then
            echo "two valid matrices required" >&2
            exit 1
        fi
        lines=$(wc -l < $var)
        read -a top < "$var"
        length=${#top[@]}
        lines2=$(wc -l < $var2)
        read -a top < "$var2"
        length2=${#top[@]}
        if [ $length -ne $length2 ] || [ $lines -ne $lines2 ]
        then
            echo "Matrices are different dimensions, they must be equal" >&2
            exit 1
        fi
        declare -a m1=()
        declare -a m2=()
        i=0
        while read -a arr2 ;
        do
            for ((j=0; j<$length; j++))
            do
                m1[$i]=${arr2[$j]}
                ((i+=1))
            done
        done < "$var"
        i=0
        while read -a arr ;
        do
            for ((j=0; j<$length; j++))
            do
                m2[$i]=${arr[$j]}
                ((i+=1))
            done
        done < "$var2"
        l=0
        for ((i=0; i<lines; i++))
        do
            for ((j=0; j<length-1; j++))
            do
                temp=$((m1[l] + m2[l]))
                printf "%s"$temp
                printf "	"
                ((l+=1))
            done
            temp=$((m1[l] + m2[l]))
            ((l+=1))
            printf "%s"$temp
            printf "\n"
        done
        exit 0
        ;;
    multiply)
        if [ $valid2 -ne 1 ]
        then
            echo "two valid matrices required" >&2
            exit 1
        fi
        row1=$(wc -l < $var)
        read -a top < "$var"
        col1=${#top[@]}
        row2=$(wc -l < $var2)
        read -a top < "$var2"
        col2=${#top[@]}
        if [ $col1 -ne $row2 ]
        then
            echo "Matrix no work"
            exit 1
        fi
        cf=$row1
        rf=$col2
        declare -a m1=()
        declare -a m2=()
        declare -a product=()
        i=0
        while read -a arr2 ;
        do
            for ((j=0; j<$col1; j++))
            do
                m1[$i]=${arr2[$j]}
                ((i+=1))
            done
        done < "$var"
        i=0
        while read -a arr ;
        do
            for ((j=0; j<$col2; j++))
            do
                m2[$i]=${arr[$j]}
                ((i+=1))
            done
        done < "$var2"
        for ((i=0; i<rf; i++))
        do
            for ((j=0; j<cf; j++))
            do
                op1=0
                for ((k=0; k<col1; k++))
                do
                    idx=$((k+col1*i))
                    idy=$((j+col2*k))
                    temp1=${m1[$idx]}
                    temp2=${m2[$idy]}
                    op2=$((temp1*temp2))
                    op1=$((op1+op2))
                    
                done
                idx=$((i*cf+j))
                product[$idx]=$op1
            done
        done
        index=0
        for ((i=0; i<rf; i++))
        do
            for ((j=0; j<cf-1; j++))
            do
                printf "%s"${product[$index]}
                printf "	"
                ((index+=1))
            done
            printf "%s"${product[$index]}
            printf "\n"
            ((index+=1))
        done
        exit 0
        ;;
    \?) 
        echo "enter: dims, transpose, mean, add, or multiply" >&2
        exit 2
        ;;
esac
exit 0